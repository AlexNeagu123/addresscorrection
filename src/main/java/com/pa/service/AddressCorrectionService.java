package com.pa.service;

import com.google.common.collect.Multimap;
import com.pa.entity.Address;
import com.pa.entity.Branch;
import com.pa.entity.FieldToken;
import com.pa.entity.GeoNode;
import com.pa.mapper.BranchMapper;
import com.pa.utility.AddressNormalizer;
import com.pa.utility.CandidateScorer;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.HashSet;
import java.util.List;

/**
 * This service is directly responsible for correcting an address and returning the result to the
 * {@link com.pa.controller.AddressCorrectionController}
 * <p>
 * Firstly, the input {@link Address} is normalized and transformed into a list of {@link FieldToken} objects
 * <p>
 * Then, a new list is generated by combining consecutive {@link FieldToken} objects from the initial list (up to 5)
 * <p>
 * Using the compound list, all the candidate {@link Branch} solutions are generated and the best one is chosen and returned
 *
 * @author Alex Neagu
 * @author Cristian Fiodorov
 */
@Service
@RequiredArgsConstructor
public class AddressCorrectionService {
    private final CandidateGeneratorService candidateGenerator;
    private final Multimap<GeoNode, String> nodeToAlternativeMap;

    /**
     * @param address The {@link Address} object received by the API
     * @return The corrected address
     */
    public Address correctAddress(Address address) {
        List<FieldToken> fieldTokens = AddressNormalizer.normalizeAddress(address);
        HashSet<FieldToken> compoundTokensSet = new HashSet<>(AddressNormalizer.getCompoundTokens(fieldTokens));
        System.out.println("All field tokens: " + compoundTokensSet);

        List<Branch> candidateBranches = candidateGenerator.generateCandidateAddresses(compoundTokensSet);

        CandidateScorer candidateScorer = new CandidateScorer(compoundTokensSet, candidateBranches, nodeToAlternativeMap);
        return BranchMapper.mapToAddress(candidateScorer.getBestCandidate());
    }
}
